--- 
layout: post
comments: true
title: !binary |
  MTXmraXliJvlu7rkuIDkuKrmtYvor5XpqbHliqjvvIhURETvvInnmoRSYWls
  c+W6lOeUqO+9ng==

date: 2007-5-23
link: false
categories: life
---
题外话：这个文章展示了一种测试驱动（TDD）的开发模式，针对Rails的基本步骤，原文很清楚，我就随便翻译下关键的部分，见下：原文地址：http://andrzejonsoftware.blogspot.com/2007/05/15-tdd-steps-to-create-rails.html15 TDD steps to create a Rails applicationIntroductionSeveral times recently, I have been asked how to develop a Rails application using the Test Driven Development approach. I'm not an expert here, but I've put together some notes on how to start working on a Rails application whilst being test-driven all the time.As an example I will use a word-learning web application. The simplest use case is to display a random word object (with its polish translation) from the database.Every time we refresh we want to see a different word.1. Create a new Rails applicationsrails my_appcd my_appRun tests with 'rake test'. It fails due to missing database configuration.2. Set up the databases - config/database.ymlThe code below assumes sqlite3 databases. development:   adapter: sqlite3   database: db/my_app_development.sqlite test:   adapter: sqlite3   database: db/my_app_test.sqlite'rake test' now runs fine.3. Create a Word class with a corresponding unit testscript/generate model Word4. Write a unit test for the Word class. Edit the test/unit/word_test.rb. def test_word_is_english_and_polish   word = Word.new :eng=&gt;'never', :pl=&gt;'nigdy'   assert_equal 'never', word.eng   assert_equal 'nigdy', word.pl end'rake test' now fails due to missing words table.5. Edit db/migrate/001_create_words.rbWe are using a migration here in order to create a table. It's a recommended way of dealing with database changes.  def self.up    create_table :words do |t|      t.column :eng, :string      t.column :pl, :string    end        Word.new(:eng=&gt;'yes', :pl=&gt;'tak').save    Word.new(:eng=&gt;'no', :pl=&gt;'nie').save    Word.new(:eng=&gt;'everything', :pl=&gt;'wszystko').save  end  def self.down    drop_table :words  endThe sample words that we are adding use Word.new .. lines, will be added to the development database. It's important to distinguish the 'test' and 'development' database. The first one is only used during tests. The latter is used by default when you start the application.Apply the migration with 'rake db:migrate'.'rake test' now succeeds with the following:'1 tests, 2 assertions, 0 failures, 0 errors'6. Fixtures and test for word.random. Edit word_test again.It's not easy to test a method which behaves randomly. Let's assume that it's enough to test that if we have only two words in our database then one of them should be called at least once per 10 calls.fixtures :wordsdef test_random results = [] 10.times {results &lt;&lt; Word.random.eng} assert results.include?(&quot;yes&quot;)endNote the 'fixtures :words' line. Edit the 'words.yml' file.yes: id: 1 pl: 'tak' eng: 'yes'no: id: 2 pl: 'nie' eng: 'no'This will be loaded to the test database before every run of tests.7. Implement the Word.random method  def self.random    all = Word.find :all    all[rand(all.size)]  endWarning: The code above could be slow for many words in a database (we retrieve all words only for selecting a random element). It's good enough for our needs.8. Generate the Words controller with a 'learn' actionscript/generate controller Words learn9. Write a test for the learn methodJust as there is a one-to-one ratio between unit tests and models, so there is between functional tests and controllers. The Controller's responsibility is to retrieve objects from the Model layer and pass them to the View. Let's test the View part first. We use the 'assigns' collection which contains all the objects passed to the View.def test_learn_passes_a_random_word  get 'learn'  assert_kind_of Word, assigns('word')end10. Make the Test Passdef learn  @word = Word.newend11. Write more tests in the words_controller_testHow can we test that controller uses the Word.random method? We don't want to duplicate the tests for the Word.random method.Mocks to the rescue! We will only test that the controller calls the Word.random method. The returned value will be faked with a prepared word.Let's install the mocha framework:gem install mochaNow we can use 'expects' and 'returns' methods.'expects' is used for setting an expectation on an object or a class. In this case we expect that the 'random' method will be called. We also set a return value by using 'returns' method. Setting a return value means faking (stubbing) the real method. The real Word.random won't be called. If an expectation isn't met the test fails.require 'mocha'def test_learn_passes_a_random_word  random_word = Word.new  Word.expects(:random).returns(random_word)  get 'learn'  assert_equal random_word, assigns('word')end'rake test' now fails. The Word.method wasn't called.12. Rewrite the implementationdef learn  @word = Word.randomend'rake test' now passes.13. Test that a word is displayed:Extend the existing test with assert_tag calls.def test_learn_passes_a_random_word  random_word = Word.new(:pl=&gt;'czesc', :eng=&gt;'hello')  Word.expects(:random).returns(random_word)  get 'learn'  assert_equal random_word, assigns('word')  assert_tag :tag=&gt;'div', :child =&gt; /czesc/  assert_tag :tag=&gt;'div', :child =&gt; /hello/end14. Implement the view - learn.rhtml  &lt;div&gt;    &lt;%= word.eng %&gt;    &lt;%= word.pl %&gt;  &lt;/div&gt;15. Manual testingscript/serverGo to 'http://localhost:3000/words/learn'.Refresh several times.If you want to read more about testing in Rails go to the Guide To Testing The Rails.
